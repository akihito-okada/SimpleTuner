package com.example.simpletuner.tuner

import kotlin.math.ln
import kotlin.math.pow
import kotlin.math.roundToInt

/**
 * UI に渡すためのピッチ結果
 *
 * frequencyHz : 実際に検出された周波数
 * noteName   : 最も近い音名（例: A4, C#3）
 * cents      : その音名からのズレ量（±cent）
 */
data class PitchResult(
    val frequencyHz: Float,
    val noteName: String,
    val cents: Int
)

/**
 * 周波数（Hz）を
 *   ・音名（note）
 *   ・オクターブ
 *   ・cent（ズレ量）
 * に変換するクラス
 *
 * チューナーUI向けの「人間に分かる形」への変換担当
 */
class NoteMapper(
    // 基準音 A4 の周波数（通常は 440Hz）
    private val a4Hz: Float = 440f
) {

    // 半音12個分の音名テーブル（C始まり）
    private val noteNames = listOf(
        "C", "C#", "D", "D#", "E", "F",
        "F#", "G", "G#", "A", "A#", "B"
    )

    /**
     * 周波数（Hz）を PitchResult に変換する
     */
    fun map(frequencyHz: Float): PitchResult {

        // ---------------------------------------------------------
        // 1) 周波数 → MIDIノート番号（浮動小数）
        //
        // MIDIでは A4 = 69 と決められている
        // 1オクターブ = 12半音
        //
        // ln(f / A4) / ln(2) で
        // 「A4から何オクターブ離れているか」を求めている
        // ---------------------------------------------------------
        val noteFloat =
            69f + 12f * (ln(frequencyHz / a4Hz) / ln(2.0).toFloat())

        // ---------------------------------------------------------
        // 2) 最も近い半音（整数のMIDIノート番号）
        //
        // チューナーでは「一番近い音名」を基準にするため
        // 四捨五入している
        // ---------------------------------------------------------
        val note = noteFloat.roundToInt()

        // ---------------------------------------------------------
        // 3) そのノート番号に対応する「理論上の周波数」
        //
        // ここが cent 計算の基準になる
        // ---------------------------------------------------------
        val nearestHz =
            a4Hz * 2f.pow((note - 69) / 12f)

        // ---------------------------------------------------------
        // 4) cent の計算
        //
        // cent = 半音の 1/100
        // 1オクターブ = 1200 cent
        //
        // 今の周波数が、最も近い音から
        // どれだけズレているかを求めている
        // ---------------------------------------------------------
        val centsFloat =
            1200f * (ln(frequencyHz / nearestHz) / ln(2.0).toFloat())

        // UIでは整数で十分なので丸める
        val cents = centsFloat.roundToInt()

        // ---------------------------------------------------------
        // 5) ノート番号 → 音名
        //
        // %12 で半音テーブルに対応付ける
        // 負数対策として +12 → %12 をしている
        // ---------------------------------------------------------
        val name = noteNames[(note % 12 + 12) % 12]

        // ---------------------------------------------------------
        // 6) オクターブ番号
        //
        // MIDIノートは C-1 = 0 なので
        // チューナー表記に合わせて -1 している
        // ---------------------------------------------------------
        val octave = (note / 12) - 1

        // ---------------------------------------------------------
        // 7) UI向けの結果としてまとめて返す
        // ---------------------------------------------------------
        return PitchResult(
            frequencyHz = frequencyHz,
            noteName = "$name$octave",
            cents = cents
        )
    }
}
